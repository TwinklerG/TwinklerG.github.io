# 算法入门



## 位运算

### 子集的异或总和再求和

([1863. 找出所有子集的异或总和再求和 - 力扣](https://leetcode.cn/problems/sum-of-all-subset-xor-totals/))

伪代码：每个子集选与不选分别为0与1，各种选法均代表一个独一的十进制数，共2^n^种。在每个循环中再遍历每个元素，判断其所在位在当前选法的二进制数对应位是否均为1，若为则选；否则不选。

```c++
int subsetXORSum(vector<int>& nums) {
    int i,j,ans = 0;
    for (int i = 0; i < 1<<nums.size(); i++){
        int sum = 0;
        for (int j = 0; j < nums.size(); j++){
            if (i & 1<<j){
                sum ^= nums[j];
            }
        }
        ans += sum;
    }
    return ans;
}
```

### 两整数之和

([371. 两整数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-two-integers/description/))

伪代码：两整数的二进制表示相同位均为1时产生进位，否则采用异或运算。

```c++
int getsum(int a, int b){
    return b == 0 ? a : getsum(a ^ b, (a & b) << 1);
}
```

### 插入

([面试题 05.01. Insert Into Bits LCCI - 力扣](https://leetcode.cn/problems/insert-into-bits-lcci/description/))

伪代码：先将目标段位清零，再与目标值左移指定位的结果位或。

```c++
int insertBits(int N, int M, int i, int j) {
    for (int k = i; k <= j; k++){
      N = N & ~(1<<k);
    }
    N |= (M<<i);
    return N;
}
```

### 子集II

([90. 子集 II - 力扣（LeetCode）](https://leetcode.cn/problems/subsets-ii/description/))

思路：每个子集代表一个二进制数，注意舍重。

```c++
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<vector<int>>ans;
        sort(nums.begin(),nums.end());
        for (int i = 0; i < 1<<nums.size(); i++){
            vector<int>tmp;
            for (int j = 0; j < nums.size(); j++){
                if (i & (1<<j)){
                    tmp.emplace_back(nums[j]);
                }
            }
            int flag = 1;
            for (auto p = ans.begin(); p < ans.end(); p++){
                if (*p == tmp){
                    flag = 0;
                    break;
                }
            }
            if (flag){
                ans.emplace_back(tmp);
            }
        }
        return ans;
    }
};
```

>  但是其实这题的最优解是深度优先搜索。

## 动态规划

### 打家劫舍

([LCR 089. 打家劫舍 - 力扣](https://leetcode.cn/problems/Gu0c2T/))

伪代码：第i家获的最大值为第i-1家获得的最大值或第i-2家与偷第i家的最大值。

```c++
int rob(vector<int>& nums) {
    if (nums.size() == 1){
        return nums[0];
    }
    int dp[101] = {0};
    dp[0] = nums[0];
    dp[1] = max(nums[0],nums[1]);
    for (int i = 2; i < nums.size(); i++){
        dp[i] = max(dp[i - 1],dp[i - 2] + nums[i]);
    }
    return dp[nums.size() - 1];
}
```

### 打家劫舍II

([LCR 089. 打家劫舍 - 力扣](https://leetcode.cn/problems/Gu0c2T/))

伪代码：采用`dp[maxN][2]`的动态规划数组，第二维0表示起始点未选，第二维1表示起始点选择。

```c++
#define maxN 101
int rob(vector<int> &nums) {
  int dp[maxN][2] = {0};
  if (nums.size() == 1) {
    return nums[0];
  } else if (nums.size() == 2) {
    return max(nums[0], nums[1]);
  }
  dp[0][0] = 0;
  dp[0][1] = nums[0];
  for (int i = 1; i < nums.size(); i++) {
    for (int j = 0; j < 2; j++) {
      if (i == 1) {
        if (j == 1) {
          dp[i][j] = nums[0];
        } else {
          dp[i][j] = nums[1];
        }
      }
      if (i == nums.size() - 1 && j == 1) {
        dp[i][j] = dp[i - 1][j];
      } else {
        dp[i][j] = max(dp[i - 1][j], dp[i - 2][j] + nums[i]);
      }
    }
  }
  return max(dp[nums.size() - 1][0], dp[nums.size() - 1][1]);
}
```

### 分隔数组以得到最大值

([1043. 分隔数组以得到最大和 - 力扣](https://leetcode.cn/problems/partition-array-for-maximum-sum/description/))

伪代码：采用`dp[i]`表示当前子数组的最大值，状态转移为一个一重循环遍历查找最大值。

```c++
int maxSumAfterPartitioning(vector<int> &arr, int k) {
  int dp[500] = {0};
  for (int i = 0; i < arr.size(); i++) {
    int cut = 0;
    int maxv = arr[i];
    for (int j = i; j >= 0; j--) {
      cut++;
      if (cut > k) {
        break;
      }
      if (arr[j] > maxv) {
        maxv = arr[j];
      }
      if (j) {
        dp[i] = max(dp[i], dp[j - 1] + cut * maxv);
      } else {
        dp[i] = max(dp[i], cut * maxv);
      }
    }
  }
  return dp[arr.size() - 1];
}
```

### 单词拆分

([139. 单词拆分 - 力扣](https://leetcode.cn/problems/word-break/submissions/502015058/))

思路：状态转移时对每一个元素进行判断，有一个满足则成立。

```c++
bool wordBreak(string s, vector<string> &wordDict) {
  int dp[301] = {0};
  for (int i = 0; i < s.size(); i++) {
    for (int j = 0; j < wordDict.size(); j++) {
      int len = wordDict[j].size();
      if (i - len + 1 < 0) {
        continue;
      }
      if (i - len != -1 && !dp[i - len]) {
        continue;
      }
      int k;
      for (k = 0; k < len; k++) {
        if (wordDict[j][k] != s[i - len + 1 + k]) {
          break;
        }
      }
      if (k == len) {
        dp[i] = 1;
      }
    }
  }
  return dp[s.size() - 1];
}
```

==前缀和==：递推求和

二维前缀和

### 最长递增子序列

([300. 最长递增子序列 - 力扣](https://leetcode.cn/problems/longest-increasing-subsequence/description/))

思路：对于每个数组元素，遍历其之前的所有元素，若满足递增条件，则进入状态转移的判定。

```c++
class Solution {
#define maxl 2500
 public:
  int lengthOfLIS(vector<int> &nums) {
    int maxv = 1;
    int dp[maxl] = {0};
    dp[0] = 1;
    for (int i = 1; i < nums.size(); i++) {
      dp[i] = 1;
      for (int j = 0; j < i; j++) {
        if (nums[j] < nums[i]) {
          dp[i] = max(dp[j] + 1, dp[i]);
        }
      }
      if (maxv < dp[i]) {
        maxv = dp[i];
      }
    }
    return maxv;
  }
};
```

### 最长的斐波那契子数列

([LCR 093. 最长的斐波那契子序列的长度 - 力扣（LeetCode）](https://leetcode.cn/problems/Q91FMA/))

思路：用一个`dp[i][j]`记录第i位数字与第j位数字构成的最长的斐波那契子数列。用二分查找对应元素的下标。

==特殊技巧==：定义二分查找函数时，采用引用而非深拷贝可以大大提高运行速度，防止超时。

```c++
class Solution {
    int dp[1000][1000];
    int findv(vector<int>& arr, int l, int r, int val){
        while (l <= r){
            int mid = (l + r) >> 1;
            if (arr[mid] == val){
                return mid;
            } else if (arr[mid] > val){
                r = mid - 1;
            } else {
                l = mid + 1; 
            }
        }
        return -1;
    }
public:
    int lenLongestFibSubseq(vector<int>& arr) {
        int ans = 1;
        for (int i = 0; i < arr.size(); i++){
            for (int j = 0; j < i; j++){
                int idex = findv(arr,0,j-1,arr[i] - arr[j]);
                if (idex != -1){
                    dp[i][j] = dp[j][idex] + 1;
                } else {
                    dp[i][j] = 2;
                }
                ans = max(dp[i][j],ans);
            }
        }
        return ans > 2 ? ans : 0;
    }
};
```

### 最长回文子序列

([516. 最长回文子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-subsequence/submissions/502170648/))

思路一：将原字符串翻转的结果与原字符串求最大相同子序列长度即为结果。

思路二：动态规划原来的字符串，`dp[i][j]`表示从i到j的最长回文子序列长度。

* 思路一代码：

```c++
class Solution {
public:
    int maxsame(string s1, string s2){
        int maxl = 0;
        int dp[1000][1000] = {0};
        for (int i = 0; i < s1.size(); i++){
            for (int j = 0; j < s2.size(); j++){
                if (s1[i] == s2[j]){
                    if (i == 0 || j == 0){
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = dp[i - 1][j - 1] + 1;
                    }
                } else {
                    if (i == 0 && j == 0){
                        dp[i][j] = 0;
                    } else if (i == 0){
                        dp[i][j] = dp[i][j - 1];
                    } else if (j == 0){
                        dp[i][j] = dp[i - 1][j];
                    } else {
                        dp[i][j] = max(dp[i - 1][j],dp[i][j - 1]);
                    }
                }
                if (maxl < dp[i][j]){
                    maxl = dp[i][j];
                }
            }
        }
        return maxl;
    }
    int longestPalindromeSubseq(string s) {
        string s2 = s;
        reverse(s2.begin(),s2.end());
        return maxsame(s,s2);
    }
};
```

* 思路二代码：

==注意==：状态转移的循环顺序。

```c++
class Solution {
    int dp[1000][1000] = {0};
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        int ans = 1;
        for (int i = n - 1; i >= 0; i--){
            dp[i][i] = 1;
            for (int j = i + 1; j < n; j++){
                if (s[i] == s[j]){
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = max(dp[i + 1][j],dp[i][j - 1]);
                }
                if (dp[i][j] > ans){
                    ans = dp[i][j];
                }
            }
        }
        return ans;
    }
};
```

### 编辑距离

思路：`dp[i][j]` 代表 `word1` 中前 `i` 个字符，变换到 `word2` 中前 `j` 个字符，最短需要操作的次数。状态转移：

增：`dp[i][j] = dp[i][j - 1] + 1`

删：`dp[i][j] = dp[i - 1][j] + 1`

改：`dp[i][j] = dp[i - 1][j - 1] + 1`

==注意==：需要考虑 `word1` 或 `word2` 一个字母都没有，即全增加/删除的情况，所以预留 `dp[0][j]` 和 `dp[i][0]`。

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int dp[501][501] = {0};
        for (int i = 0; i <= word1.size(); i++){
            dp[i][0] = i;
        }
        for (int i = 0; i <= word2.size(); i++){
            dp[0][i] = i;
        }
        for (int i = 1; i <= word1.size(); i++){
            for (int j = 1; j <= word2.size(); j++){
                if (word1[i - 1] == word2[j - 1]){
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

### 买卖股票的最佳时机III

([123. 买卖股票的最佳时机 III - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/))

思路：动态规划，3个维度，分别为当前元素位置，是否持有股票，完成的交易次数。

==注意==：设定非法状态。

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int ans = 0;
        int dp[100000][2][3] = {0};
        int n = prices.size();
        memset(dp,-0x3f3f3f3f,sizeof(dp));
        for (int i = 0; i < n; i++){
            dp[i][0][0] = 0;
        }
        dp[0][1][1] = -prices[0];
        for (int i = 1; i < prices.size(); i++){
            for (int k = 1; k < 3; k++){
                dp[i][0][k] = max(dp[i - 1][0][k], dp[i - 1][1][k] + prices[i]);
                dp[i][1][k] = max(dp[i - 1][0][k - 1] - prices[i], dp[i - 1][1][k]);
            }
        }
        return max({0,dp[prices.size() - 1][0][1],dp[prices.size() - 1][0][2]});
    }
};
```

### 分割等和数组

([LCR 101. 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/NUPfPr/description/))

思路：数组和为奇数，显然不成立。否则则判断是否数组可选子集和为数组和的一半。对于每个元素，有有选和不选两种情况。定义一个`dp[i]`数组，表示是否可以凑成和为i的子集。

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int dp[200100] = {0};
        int sum = 0;
        int n = nums.size();
        for (int i = 0; i < n; i++){
            sum += nums[i];
        }
        if (sum % 2){
            return false;
        }
        sum /= 2;
        dp[0] = 1;
        for (int i = 0; i < n; i++){
            for (int j = sum; j >= nums[i]; j--){
                dp[j] |= dp[j - nums[i]];
            }
            if (dp[sum]){
                return true;
            }
        }
        return false;
    }
};
```

### 矩阵中的最长递增路径

([LCR 112. 矩阵中的最长递增路径 - 力扣（LeetCode）](https://leetcode.cn/problems/fpTFWP/))

思路：==记忆化搜索==。对于每个位置，进行四个方向的试探，求出当前位置为**终点**的最长递增路径。

> dfs：深度优先搜索。

```c++
class Solution {
    int vect[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};
    int dp[201][201];
public:
    int dfs(vector<vector<int>>& matrix, int x, int y, int dp[][201], int m, int n){
        //已经搜索过
        if (dp[x][y] != -1){
            return dp[x][y];
        }
        //新的搜索
        dp[x][y] = 1;
        int tx, ty;
        for (int i = 0; i < 4; i++){
            tx = x + v[i][0];
            ty = y + v[i][1];
            if (tx < 0 || ty < 0 || tx >= m || ty >= n){
                continue;
            }
            if (matrix[tx][ty] >= matrix[x][y]){
                continue;
            }
            dp[x][y] = max(dp[x][y],dfs(matrix,tx,ty,dp,m,n) + 1);
        }
        return dp[x][y];
    }
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        int ans = 1;
        memset(dp,-1,sizeof(dp));
        for (int i = 0; i < matrix.size(); i++){
            for (int j = 0; j < matrix[0].size(); j++){
                ans = max(ans,dfs(matrix,i,j,dp,matrix.size(),matrix[0].size()));
            }
        }
        return ans;
    }
};
```

### 快速幂乘法

([50. Pow(x, n) - 力扣（LeetCode）](https://leetcode.cn/problems/powx-n/))

思路：通过动态规划，每次指数折半来达到O(logn)的时间复杂度。

递归法：

```c++
class Solution {
    double quickmul(double x, long long n){
        if (n == 0){
            return 1.0;
        }
        double y = quickmul(x, n / 2);
        return n % 2 ? y * y * x : y * y;
    }
public:
    double myPow(double x, int n) {
        return n >= 0 ? quickmul(x, n) : 1.0 / quickmul(x, -(long long)n);
    }
};
```

## 滚动数组优化

* 当动态规划状态转移中`dp[i][j]`只和`dp[i - 1][j]`或`dp[i][j - 1]`相关时可以采用滚动数组将O(mn)的时间复杂度降到O(m)

经典例题

* [63. 不同路径 II - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths-ii/description/)
* [70. 爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/climbing-stairs/description/)
* [LCR 165. 解密数字 - 力扣（LeetCode）](https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/description/)

### 交错字符串

思路：其实这题可以采用深度优先搜索的递归做法，但会内存时间超限。故采用动态规划。

未优化的代码：

```c++
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        int n1 = s1.size(), n2 = s2.size(), n3 = s3.size();
        vector<vector<int>> f(n1 + 1,vector<int>(n2 + 1, 0));
        if (n1 + n2 != n3){
            return false;
        }
        f[0][0] = 1;
        for (int i = 0; i <= n1; i++){
            for (int j = 0; j <= n2; j++){
                int p = i + j - 1;
                if (i > 0){
                    f[i][j] |= (f[i - 1][j] && s3[p] == s1[i - 1]);
                }
                if (j > 0){
                    f[i][j] |= (f[i][j - 1] && s3[p] == s2[j - 1]);
                }
            }
        }

        return f[n1][n2];
    }
};
```

采用滚动数组优化的代码：

```c++
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        int n1 = s1.size(), n2 = s2.size(), n3 = s3.size();
        vector<int> f(n2 + 1,0);
        if (n1 + n2 != n3){
            return false;
        }
        f[0] = 1;
        for (int i = 0; i <= n1; i++){
            for (int j = 0; j <= n2; j++){
                int p = i + j - 1;
                if (i > 0){
                    f[j] &= (s1[i - 1] == s3[p]);
                }
                if (j > 0){
                    f[j] |= (f[j - 1] && s2[j - 1] == s3[p]);
                }
            }
        }

        return f[n2];
    }
};
```

## 前缀和

* 前缀和的本质是一种动态规划。

**一维前缀和**：状态转移：`dp[i] = dp[i - 1] + nums[i]`

### 长度最小的子数组

下回分解：[长度最小的子数组](###长度最小的子数组)。

**二维前缀和**：状态转移：`dp[i][j] = nums[i][j] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]`

### 矩阵区域和

思路：先采用前缀和遍历计算所有区块的`dp`值，然后遍历求结果。

```c++
class Solution {
public:
    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {
        int sum[101][101];
        memset(sum,0,sizeof(sum));
        int m = mat.size(), n = mat[0].size();
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                sum[i][j] += mat[i][j];
                if (i > 0){sum[i][j] += sum[i - 1][j];}
                if (j > 0){sum[i][j] += sum[i][j - 1];}
                if (i > 0 && j > 0){
                    sum[i][j] -= sum[i - 1][j - 1];
                }
            }
        }
        vector<vector<int>> ans;
        for (int i = 0; i < m; i++){
            vector<int> tmp;
            for (int j = 0; j < n; j++){
                int tem = 0;
                tem += sum[min(m - 1,i + k)][min(n - 1, j + k)];
                if (i - k - 1 >= 0){
                    tem -= sum[i - k - 1][min(n - 1, j + k)];
                }
                if (j - k - 1 >= 0){
                    tem -= sum[min(m - 1,i + k)][j - k - 1];
                }
                if (i - k - 1 >= 0 && j - k - 1 >= 0){
                    tem += sum[i - k - 1][j - k - 1];
                }
                tmp.push_back(tem);
            }
            ans.push_back(tmp);
        }
        return ans;
    }
};
```



## 哈希表

### 和相同的二元子数组

([930. 和相同的二元子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-subarrays-with-sum/))

思路：**前缀和**+**查分**。然后用**哈希表**存取前缀和，边遍历，边计算。

```c++
class Solution {
public:
    int numSubarraysWithSum(vector<int>& nums, int goal) {
        int sum[30001] = {0};
        int hash[60001] = {0};
        hash[0] = 1;
        sum[0] = nums[0];
        int ans = 0;
        for (int i = 0; i < nums.size(); i++){
            if (i == 0){
                sum[i] = nums[i];
            } else {
                sum[i] = sum[i - 1] + nums[i];
            }
            if (sum[i] >= goal){
                ans += hash[sum[i] - goal];
            }
            hash[sum[i]]++;
        }
        return ans;
    }
};
```

变式：数据范围变大。利用C++中STL中的`unordered_map`模拟哈希表。

([LCR 010. 和为 K 的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/QTMn0o/description/))

```c++
class Solution {
    unordered_map<int,int> hash;
public:
    int subarraySum(vector<int>& nums, int k) {
        int sum[20000] = {0};
        hash[0] = 1;
        int ans = 0;
        for (int i = 0; i < nums.size(); i++){
            if (i == 0){
                sum[i] = nums[i];
            } else {
                sum[i] = sum[i - 1] + nums[i];
            }
            ans += hash[sum[i] - k];
            hash[sum[i]]++;
        }
        return ans;
    }
};
```

### 四数相和II

([454. 四数相加 II - 力扣（LeetCode）](https://leetcode.cn/problems/4sum-ii/description/))

思路：时间复杂度控制在O(n^2^)。采用一个**红黑表**记录`nums1`,`nums2`中的的和的出现次数，再用一个二重循环遍历`nums3`,`nums4`求出结果。

```c++
class Solution {
    unordered_map<int,int> hash;
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        for (int i = 0; i < nums1.size(); i++){
            for (int j = 0; j < nums2.size(); j++){
                hash[-(nums1[i] + nums2[j])]++;
            }
        }
        int ans = 0;
        for (int i = 0; i < nums3.size(); i++){
            for (int j = 0; j < nums4.size(); j++){
                ans += hash[nums3[i] + nums4[j]];
            }
        }
        return ans;
    }
};
```

### 相交链表

([LCR 023. 相交链表 - 力扣（LeetCode）](https://leetcode.cn/problems/3u1WK4/description/))

思路：定义一个特殊的哈希表。`unordered_map<ListNode*,bool>`。使用`.find()`方法。时间复杂度O(m+n)。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    unordered_map<ListNode*,bool> hash;
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        while(headA != NULL){
            hash[headA] = true;
            headA = headA->next;
        }
        while(headB != NULL){
            if (hash.find(headB) != hash.end()){
                return headB;
            }
            headB = headB->next;
        }
        return NULL;
    }
};
```

> 补充：双指针，数学方法。时间复杂度O(1)。

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *h1 = headA, *h2 = headB;
        if (!h1 || !h2){
            return NULL;
        }
        while (h1 != h2){
            h1 = h1 == NULL ? headB : h1->next;
            h2 = h2 == NULL ? headA : h2->next;
        }
        return h1;
    }
};
```

### 滑动窗口的最大值

([239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/))

思路：线段树 && 单调队列。通过一个模拟双端队列存取数组下标，头元素为最大值的下标。每次遍历判断是否超长度和大小更新。

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int q[100010] = {0},front = 0,back = 0;
        vector<int> ret;
        for (int i = 0; i < nums.size(); i++){
            while (front != back && i - q[front] > k - 1){
                front++;
            }
            while (front != back && nums[i] >= nums[q[back - 1]]){
                back--;
            }
            q[back++] = i;
            if (i - k + 1 >= 0){
                ret.push_back(nums[q[front]]);
            }
        }   
        return ret;
    }
};
```

> ret：*RET*是子程序的返回指令。

## 贪心

算法的核心在于数学逻辑的推理，寻找最佳选择。

### 分割平衡字符串

([1221. 分割平衡字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/split-a-string-in-balanced-strings/description/))

思路：每次满足平衡计数器就加一，最后计数器的结果即为所求的值。

```c++
class Solution {
public:
    int balancedStringSplit(string s) {
        int cut = 0;
        int ans = 0;
        for (int i = 0; i < s.size(); i++){
            cut += s[i] == 'L' ? 1 : -1;
            if (cut == 0){
                ans++;
            }
        }
        return ans;
    }
};
```

### 加油站

([134. 加油站 - 力扣（LeetCode）](https://leetcode.cn/problems/gas-station/description/))

思路：从i位置出发，如果无法到达j位置，则从i~j中任一位置出发都无法到达j位置，所以下一次直接让i从j位置出发。

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n = gas.size();
        int i = 0;
        while (i < n){
            int cur = 0, cut = 0;
            while (cut < n){
                int j = (i + cut) % n;
                cur += (gas[j] - cost[j]);
                if (cur < 0){
                    break;
                }
                cut++;
            }
            if (cut == n){
                return i;
            } else {
                i = i + cut + 1;
            }
        }
        return -1;
    }
};
```

### 十-二进制数的最小数目

([1689. 十-二进制数的最少数目 - 力扣（LeetCode）](https://leetcode.cn/problems/partitioning-into-minimum-number-of-deci-binary-numbers/description/))

思路：各个位数中最大的为最小数目，应为每次加0或加1。

```c++
class Solution {
public:
    int minPartitions(string n) {
        int ans = 0;
        for (int i = 0; i < n.size(); i++){
            if (ans < n[i] - '0'){
                ans = n[i] - '0';
            }
        }  
        return ans;
    }
};
```

### 使二叉树所有路径值相等的最小代价

([2673. 使二叉树所有路径值相等的最小代价 - 力扣（LeetCode）](https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/description/?envType=daily-question&envId=Invalid Date))

思路：自底向上。因为两个叶节点的祖先值改变对于叶节点没有影响，因此从后往前遍历，发现叶节点值不同便计入答案，然后将叶节点的值加入其祖先中，直至根节点。

```c++
class Solution {
public:
    int minIncrements(int n, vector<int>& cost) {
        int ans = 0;
        for (int i = n - 2; i > 0; i -= 2){
            ans += abs(cost[i] - cost[i + 1]);
            cost[i / 2] += max(cost[i], cost[i + 1]);
        }
        return ans;
    }
};
```



## 滑动窗口

==注意==：多采用线段树+单调队列的思想。

### 学生分数的最小差值

([1984. 学生分数的最小差值 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/description/))

思路：先排序，再采用滑动窗口算两个端点的差值。

```c++
class Solution {
public:
    int minimumDifference(vector<int>& nums, int k) {
        int n = nums.size();
        sort(nums.begin(),nums.end());
        int j = -1;
        int ans = 0x7fffffff;
        while (j < n - 1){
            j++;
            int i = j - k + 1;
            if (i < 0){
                continue;
            }
            ans = min(ans,nums[j] - nums[i]);
        }
        return ans;
    }
};
```

### 乘积小于k的子数组

思路：采用一个滑动窗口。因为每一个数组元素大于等于1，所以左边i下标越大，当前prod越小。遍历右边j下标，并移动i下标（j越大，当前prod越大，所以i可以继承上一次j的状态）。

```c++
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        int n = nums.size();
        int ret = 0, i = 0, prod = 1;
        for (int j = 0; j < n; j++){
            prod *= nums[j];
            while (i <= j && prod >= k){
                prod /= nums[i];
                i++;
            }
            ret += j - i + 1;
        }
        return ret;
    }
};
```

### 最大连续1的个数III

([1004. 最大连续1的个数 III - 力扣（LeetCode）](https://leetcode.cn/problems/max-consecutive-ones-iii/description/))

思路：同上一题。

```c++
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int prod = 0,ret = 0;
        int i = 0;
        for (int j = 0; j < nums.size(); j++){
            prod += (nums[j] == 0);
            while (i <= j && prod > k){
                prod -= (nums[i] == 0);
                i++;
            }
            ret = max(ret,j - i + 1);
        }
        return ret;
    }
};
```



## 双指针

### 相交链表

书接上回：[相交链表](###相交链表)

### 三数之和

([15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/description/))

思路：首先对数组排序，然后遍历第一个数，如果大于0直接退出循环，第二个数从第一个数的下一个开始遍历循环，第三个数从数组末尾开始遍历，如果小于0退出循环，然后第二第三个数形成双指针开始遍历。时间复杂度O(n^2^)~O(n^3^)。

```c++
class Solution {
public:
   vector<vector<int>> threeSum(vector<int> &nums) {
    vector<vector<int>> ans;
    int n = nums.size();
    sort(nums.begin(),nums.end());
    for (int first = 0; first < n - 2; first++){
      if (nums[first] > 0){
        continue;
      }
      if (first > 0 && nums[first] == nums[first - 1]){
        continue;
      }
      int third = n - 1;
      for (int second = first + 1; second < n - 1; second++){
        if (second > first + 1 && nums[second] == nums[second - 1]){
          continue;
        }
        while (second < third && nums[second] + nums[third] + nums[first] > 0){
          third--;
        }
        if (second == third){
          break;
        }
        if (nums[first] + nums[second] + nums[third] == 0){
          ans.push_back({nums[first],nums[second],nums[third]});
        }
      }
    }
    return ans;
  }
};
```

### 四数之和

([18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/))

思路：两层循环得到前两个数之和，再用双指针处理后两个数。伪代码类似[三数之和](###三数之和)。

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> ans;
        int n = nums.size();
        if (n < 4){
            return ans;
        }
        sort(nums.begin(),nums.end());
        long long sum4 = (long long)nums[0] + nums[1] + nums[2] + nums[3];
        if (sum4 > target){
            return ans;
        }
        for (int i = 0; i < n - 3; i++){
            if (i > 0 && nums[i] == nums[i - 1]){
                continue;
            }
            for (int j = i + 1; j < n - 2; j++){
                if (j > i + 1 && nums[j] == nums[j - 1]){
                    continue;
                }
                long long val = (long long)target - nums[i] - nums[j];
                int k = j + 1;
                int l = n - 1;
                while (k < l){
                    int sum = nums[k] + nums[l];
                    if (sum < val){
                        k++;
                    } else if (sum > val){
                        l--;
                    } else {
                        ans.push_back({nums[i],nums[j],nums[k],nums[l]});
                        l--;
                        k++;
                        while(k < l && nums[l] == nums[l + 1]){
                            l--;
                        }
                        while(k < l && nums[k] == nums[k - 1]){
                            k++;
                        }
                    }
                }
            }
        }
        return ans;
    }
};
```

### 最接近的三数之和

([16. 最接近的三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum-closest/description/))

思路：类似三数之和，但是要确保当前值大于等于target的情况后要判断下一个状态与target的差的绝对值。

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        int ans = 0x7f000000, n = nums.size();
        if (n == 3){
            return nums[0] + nums[1] + nums[2];
        }
        sort(nums.begin(),nums.end());
        for (int i = 0; i < n - 2; i++){
            if (i > 0 && nums[i] == nums[i - 1]){
                continue;
            }
            int k = n - 1;
            for (int j = i + 1; j < n - 1; j++){
                if (j > i + 1 && nums[j] == nums[j - 1]){
                    continue;
                }
                while (nums[i] + nums[j] + nums[k] - target >= 0 && k > j){
                    if (nums[i] + nums[j] + nums[k] - target < abs(ans - target)){
                        ans = nums[i] + nums[j] + nums[k];
                    }
                    k--;
                }
                if (k == j){
                    break;
                }
                if (k > j && abs(nums[i] + nums[j] + nums[k] - target) < abs(ans - target)){
                    ans = nums[i] + nums[j] + nums[k];
                }
                if (k < n - 1){
                    k++;
                }
            }
        }
        return ans;
    }
};
```

### 长度最小的子数组

([209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/description/))

思路：双指针，每次遍历总和必定增加，所以左指针可以继承上一次的位置。可采用前缀和计算当前区域和。

==注意==：起始点左为0，而不是数组的第0个元素。

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int ans = 0;
        int sum[100010] = {0};
        int j = 0;
        sum[0] = 0;
        for (int i = 1; i <= nums.size(); i++){
            sum[i] = sum[i - 1] + nums[i - 1];
            while (j < i){
                if (sum[i] - sum[j] < target){
                    break;
                }
                j++;
            }
            if (j > 0 && sum[i] - sum[j - 1] >= target){
                ans = ans == 0 ? i - j + 1 : min(ans, i - j + 1);
            }
        }
        return ans;
    }
};
```

### 下一个排列

([31. 下一个排列 - 力扣（LeetCode）](https://leetcode.cn/problems/next-permutation/description/))

思路：先将i从后往前遍历至当前i位元素小于`i+1`位元素，若i为-1直接排序返回，否则将j从后往前遍历至当前j大于i（因为子数组递减，所以是刚好比i大的最少的一个元素），将i位元素与j位元素交换后对数组切片排序即为结果。

```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i = nums.size() - 2;
        int j = nums.size() - 1;
        while (i >= 0 && nums[i + 1] <= nums[i]){
            i--;
        }   
        if (i >= 0){
            while (j > i && nums[j] <= nums[i]){
                j--;
            }
            swap(nums[i],nums[j]);
        }
        sort(nums.begin() + i + 1,nums.end());
    }
};
```

## 排序

## 计数排序（桶排序）

* [1051. 高度检查器 - 力扣（LeetCode）](https://leetcode.cn/problems/height-checker/)

## 图论

> 图论中，深度优先搜索(DFS)和广度优先搜索(BFS)是常见的图的遍历方式。

## 深度优先搜索(dfs)

前情提要：[矩阵中的最长递增路径](###矩阵中的最长递增路径)。

三大想法：递归，回溯，分治

## 递归

### N皇后II

([52. N 皇后 II - 力扣（LeetCode）](https://leetcode.cn/problems/n-queens-ii/description/))

思路：定义一个哈希表，0表示能防止的位置，再对每一行进行一次遍历，如果有可以放的位置则放置并进入下一行，然后再拿走。如果当前行数到达终点则结果数加一。

```c++
class Solution {
    int hash[10][10] = {0};
    int ans = 0;
    void doadd(int r,int c,int val,int max){
        for (int i = 0; i < max; i++){
            hash[r][i] += val;
            hash[i][c] += val;
        }
        for (int i = 0; i < max; i++){
            if (r - i >= 0 && c - i >= 0){
                hash[r - i][c - i] += val;
            }
            if (r + i < max && c + i < max){
                hash[r + i][c + i] += val;
            }
            if (r - i >= 0 && c + i < max){
                hash[r - i][c + i] += val;
            }
            if (r + i < max && c - i >= 0){
                hash[r + i][c - i] += val;
            }
        }
    }
    void dfs(int cur,int max){
        if (cur == max){
            ans++;
            return;
        }
        for (int i = 0; i < max; i++){
            if (hash[cur][i] == 0){
                doadd(cur,i,1,max);
                dfs(cur + 1,max);
                doadd(cur,i,-1,max);
            }
        }
    }
public:
    int totalNQueens(int n) {
        dfs(0,n);
        return ans;
    }
};
```

### 全排列II

([47. 全排列 II - 力扣（LeetCode）](https://leetcode.cn/problems/permutations-ii/description/))

思路：采用dfs函数，对于一个数组先排序，然后递归调用dfs，每次要先判断是否产生了重复的情况，一旦出现直接coninue。

```c++
class Solution {
    vector<vector<int>> ans;
    void dfs(vector<int>& tmp,vector<int>& nums){
        int n = nums.size();
        if (n == 0){
            ans.push_back(tmp);
            return;
        }
        for (int i = 0; i < n; i++){
            if (i > 0 && nums[i] == nums[i - 1]){
                continue;
            }
            int tem = nums[i];
            tmp.push_back(tem);
            nums.erase(nums.begin() + i);
            dfs(tmp,nums);
            tmp.pop_back();
            nums.insert(nums.begin() + i,tem);
        }
    }
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        vector<int> tmp;
        dfs(tmp,nums);
        return ans;
    }
};
```

### 括号生成

([22. 括号生成 - 力扣（LeetCode）](https://leetcode.cn/problems/generate-parentheses/))

思路：对于每一个节点，如果括号数等于回括号数等于目标数则推入答案，如果括号数小于目标数则增加括号，如果括号数大于回括号数则增加回括号。

```c++
class Solution {
    vector<string> ans;
    void dfs(int n,int prev,int nxt,string s){
        if (prev == nxt && prev == n){
            ans.push_back(s);
            return;
        }
        if (prev < n){
            s.push_back('(');
            dfs(n,prev+1,nxt,s);
            s.pop_back();
        }
        if (prev > nxt){
            s.push_back(')');
            dfs(n,prev,nxt+1,s);
            s.pop_back(); 
        }
    }
public:
    vector<string> generateParenthesis(int n) {
        string s;
        dfs(n,0,0,s);
        return ans;
    }
};
```

### 岛屿数量

([200. 岛屿数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-islands/description/?envType=study-plan-v2&envId=graph-theory))

==注意==：在dfs函数内尽量少声明变量和进行运算，否则可能导致爆栈。

```c++
class Solution {
    int vect[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};
    int ans = 0;
    int m,n;
    void dfs(vector<vector<char>>& grid, int x, int y){
        grid[x][y] = '2';
        int tx, ty;
        for (int i = 0; i < 4 ; i++){
            tx = x + vect[i][0];
            ty = y + vect[i][1];
            if (tx < 0 || ty < 0 || tx >= m || ty >= n || grid[tx][ty] != '1'){
                continue;
            }
            dfs(grid,tx,ty);
        }
    }
public:
    int numIslands(vector<vector<char>>& grid) {
        m = grid.size();
        n= grid[0].size();
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                if (grid[i][j] == '1'){
                    dfs(grid,i,j);
                    ans++;
                }
            }
        }
        return ans;
    }
};
```

### 岛屿的最大面积

([695. 岛屿的最大面积 - 力扣（LeetCode）](https://leetcode.cn/problems/max-area-of-island/description/))

思路：一定要采用引用方式改变sum，不然只能算最长线。

```c++
class Solution {
    int vect[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};
    int m,n,ans = 0;
    void dfs(vector<vector<int>>& grid,int x, int y, int& sum){
        ans = max(ans,sum);
        grid[x][y] = 2;
        for (int i = 0; i < 4; i++){
            int tx = x + vect[i][0];
            int ty = y + vect[i][1];
            if (tx < 0 || ty < 0 || tx >= m || ty >= n || grid[tx][ty] != 1){
                continue;
            }
            sum++;
            dfs(grid,tx,ty,sum);
        }
    }
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        m = grid.size();
        n = grid[0].size();
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                if (grid[i][j] == 1){
                    int sum = 1;
                    dfs(grid,i,j,sum);
                }
            }
        }
        return ans;
    }
};
```

### 统计封闭岛屿的数目

([1254. 统计封闭岛屿的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-closed-islands/description/?envType=study-plan-v2&envId=graph-theory))

思路：先尝试后判断，保证遍历所有可能的位置，防止重复的发生。

```c++
class Solution {
    int ans = 0, m, n;
    int vect[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};
    int dfs(vector<vector<int>>& grid, int x, int y){
        if (x < 0 || y < 0 || x >= m || y >= n){
            return 0;
        } else if (grid[x][y] != 0){
            return 1;
        }
        grid[x][y] = 2;
        int tmp = 1;
        for (int i = 0; i < 4; i++){
            int tx = x + vect[i][0];
            int ty = y + vect[i][1];
            if (dfs(grid,tx,ty) == 0){
                tmp = 0;
            }
        }
        return tmp;
    }
public:
    int closedIsland(vector<vector<int>>& grid) {
        m = grid.size();
        n = grid[0].size();
        for (int i = 1; i < m - 1; i++){
            for (int j = 1; j < n - 1; j++){
                if (grid[i][j] == 0 && dfs(grid,i,j)){
                    ans++;
                }
            }
        }
        return ans;
    }
};
```



### 省份数量

([547. 省份数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-provinces/description/?envType=study-plan-v2&envId=graph-theory))

思路：采用深度优先搜索思想，每次一定要注意标记与判断。

```c++
class Solution {
    int ans = 0;
    int n;
    void dfs(vector<vector<int>>& isConnected, int i, vector<int>& isc){
        isc[i] = 1;
        for (int j = 0; j < n; j++){
            if (isConnected[i][j] && isc[j] == 0){
                dfs(isConnected,j,isc);
            }
        }
    }
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        n = isConnected.size();
        vector<int> isc(n,0);
        for (int i = 0; i < n; i++){
            if (!isc[i]){
                ans++;
                dfs(isConnected,i,isc);
            }
        }
        return ans;
    }
};
```

### 找到最终的安全状态

([802. 找到最终的安全状态 - 力扣（LeetCode）](https://leetcode.cn/problems/find-eventual-safe-states/description/?envType=study-plan-v2&envId=graph-theory))

思路：记忆化搜索+三色标记。0代表未搜索到，1代表搜索到且不安全，2代表搜索到且安全。定义bool类型dfs函数进行深度优先搜索。

```c++
class Solution {
    vector<int>vis;
    vector<int>ret;
    bool dfs(vector<vector<int>>& graph,int i){
        if (vis[i] == 1){
            return false;
        }
        if (vis[i] == 2){
            return true;
        }
        vis[i] = 1;
        for (int j = 0; j < graph[i].size(); j++){
            if (!dfs(graph,graph[i][j])){
                return false;
            } else {
                vis[graph[i][j]] = 2;
            }
        }
        return true;
    }
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int n = graph.size();
        vis.resize(n);
        for (int i = 0; i < n; i++){
            if (dfs(graph,i)){
                vis[i] = 2;
                ret.push_back(i);
            }
        }
        return ret;
    }
};
```

### 钥匙和房间

([841. 钥匙和房间 - 力扣（LeetCode）](https://leetcode.cn/problems/keys-and-rooms/description/?envType=study-plan-v2&envId=graph-theory))

思路：如果满足题意，则从任一房间开始遍历都可以到达所有房间。故采用深度优先搜索。

```c++
class Solution {
    vector<int> rom;
    void dfs(vector<vector<int>>& rooms, int i){
        if (rom[i]){
            return;
        }
        rom[i] = 1;
        for (int j = 0; j < rooms[i].size(); j++){
            dfs(rooms,rooms[i][j]);
        }
    }
public:
    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        int n = rooms.size();
        rom.resize(n);
        dfs(rooms,0);
        for (int i = 0; i < n; i++){
            if (!rom[i]){
                return false;
            }
        }
        return true;
    }
};
```

### 客隆图

([133. 克隆图 - 力扣（LeetCode）](https://leetcode.cn/problems/clone-graph/description/))

思路：定义一个哈希表，存储深拷贝结果与原节点的对应。对每个节点递归调用，进行深度优先搜索。

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> neighbors;
    Node() {
        val = 0;
        neighbors = vector<Node*>();
    }
    Node(int _val) {
        val = _val;
        neighbors = vector<Node*>();
    }
    Node(int _val, vector<Node*> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
};
*/
class Solution {
    unordered_map<Node*,Node*> hash;
public:
    Node* cloneGraph(Node* node) {
        if (node == nullptr){
            return node;
        }
        //这里的find方法查找的索引，返回一个迭代器
        if (hash.find(node) != hash.end()){
            return hash[node];
        }
        Node* cloneNode = new Node(node->val);
        hash[node] = cloneNode;
        for (auto& neighbors : node->neighbors){
            cloneNode->neighbors.emplace_back(cloneGraph(neighbors));
        }
        return cloneNode;
    }
};
```



## 回溯(backtrack)

### 组合总和

([LCR 081. 组合总和 - 力扣（LeetCode）](https://leetcode.cn/problems/Ygoe9J/description/))

思路：采用深度优先搜索递归，一个类似二叉树的实现发法，对于每一个节点进行元素索引和当前总值的两次检查，判断是否进入相应分支，如果不进入则需即使返回退出，防止重复。

```c++
class Solution {
public:
    vector<vector<int>> ans;
    void dfs(vector<int>& cur,int target,vector<int>& candidates,int idx){
        if (idx == candidates.size()){
            return;
        }
        if (target == 0){
            ans.push_back(cur);
            return;
        }
        dfs(cur,target,candidates,idx + 1);
        if (target - candidates[idx] >= 0){
            cur.push_back(candidates[idx]);
            dfs(cur,target - candidates[idx],candidates,idx);
            cur.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<int> cur;
        dfs(cur,target,candidates,0);
        return ans;
    }
};
```

### 电话号码的字母组合

([17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/))

思路：回溯。对于每一个数字，递归所有可能的结果，即时推入推出。

```c++
class Solution {
 public:
  vector<string> letterCombinations(string digits) {
    vector<string> combinations;
    if (digits.empty()) {
      return combinations;
    }
    unordered_map<char, string> phoneMap{
        {'2', "abc"},
        {'3', "def"},
        {'4', "ghi"},
        {'5', "jkl"},
        {'6', "mno"},
        {'7', "pqrs"},
        {'8', "tuv"},
        {'9', "wxyz"}};
    string combination;
    backtrack(combinations, phoneMap, digits, 0, combination);
    return combinations;
  }

  void backtrack(vector<string> &combinations, const unordered_map<char, string> &phoneMap, const string &digits, int index, string combination) {
    if (index == digits.size()) {
      combinations.push_back(combination);
    } else {
      char digit = digits[index];
      const string &letters = phoneMap.at(digit);
      for (const char &letter : letters) {
        combination.push_back(letter);
        backtrack(combinations, phoneMap, digits, index + 1, combination);
        combination.pop_back();
      }
    }
  }
};
```

### 组合总和II

([40. 组合总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-ii/description/))

思路：采用回溯，为了防止重复需要先对目标数组进行排序，然后确定起始索引，递归求取结果。

```c++
class Solution {
    void tarceback(vector<int>& candidates, vector<vector<int>>& ans, int idx, int target, vector<int>& cur){
        if (target == 0){
            ans.push_back(cur);
            return;
        }
        if (idx == candidates.size()){
            return;
        }
        for (int i = idx; i < candidates.size(); i++){
            if (i > idx && candidates[i] == candidates[i - 1]){
                continue;
            }
            if (target - candidates[i] < 0){
                break;
            }
            cur.push_back(candidates[i]);
            tarceback(candidates,ans,i + 1,target - candidates[i], cur);
            cur.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        vector<vector<int>> ans;
        vector<int> cur;
        tarceback(candidates,ans,0,target,cur);
        return ans;
    }
};
```



## 广度优先搜索

### 迷宫中离入口最近的出口

([1926. 迷宫中离入口最近的出口 - 力扣（LeetCode）](https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/description/?envType=study-plan-v2&envId=graph-theory))

思路：每次向外扩散一步，采用三元组队列存储当前的合法情况，先判断位置是否合法，然后一旦到达边界则返回答案，否则加入队列。

```c++
class Solution {
public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        int m = maze.size(), n = maze[0].size();
        queue<tuple<int,int,int>> q;
        int vect[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};
        q.emplace(entrance[0],entrance[1],0);
        maze[entrance[0]][entrance[1]] = '+';
        while (!q.empty()){
            auto [cx, cy, d] = q.front();
            q.pop();
            for (int i = 0; i < 4; i++){
                int tx = cx + vect[i][0], ty = cy + vect[i][1];
                //新坐标合法且不为墙
                if (tx >= 0 && tx < m && ty >= 0 && ty < n && maze[tx][ty] != '+'){
                    if (tx == 0 || tx == m - 1 || ty == 0 || ty == n - 1){
                        return d + 1;
                    }
                    maze[tx][ty] = '+';
                    q.emplace(tx,ty,d+1);
                }
            }
        }            
        return -1;
    }
};
```

### 二叉树中的第k大层和

([2583. 二叉树中的第 K 大层和 - 力扣（LeetCode）](https://leetcode.cn/problems/kth-largest-sum-in-a-binary-tree/description/?envType=daily-question&envId=2024-02-23))

思路：对于每一层广度优先搜索，得到一层的和，最后排序得到答案。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long kthLargestLevelSum(TreeNode* root, int k) {
        queue<TreeNode *>q;
        q.push(root);
        vector<long long> levelSums;
        while (!q.empty()){
            long long levelsum = 0, size = q.size();
            for (int i = 0; i < size; i++){
                TreeNode *node = q.front();
                q.pop();
                levelsum += node->val;
                if (node->left){
                    q.push(node->left);
                }
                if (node->right){
                    q.push(node->right);
                }
            }
            levelSums.push_back(levelsum);
        }
        if (levelSums.size() < k){
            return -1;
        }
        sort(levelSums.begin(),levelSums.end());
        return *(levelSums.end() - k);
    }
};
```

### 最短的桥

([934. 最短的桥 - 力扣（LeetCode）](https://leetcode.cn/problems/shortest-bridge/description/?envType=study-plan-v2&envId=graph-theory))

思路：对于二维数组先找到一块陆地，开始广度优先搜索（深度优先搜索也可），将其直接所连的陆地均标为-1，然后对于每一个-1的陆地，开始广度优先搜索，找到一块1的陆地即返回步数。

```c++
class Solution {
 public:
  int shortestBridge(vector<vector<int>> &grid) {
    int n = grid.size();
    int vect[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    vector<pair<int, int>> island;
    queue<pair<int, int>> q;
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        if (grid[i][j] == 1) {
          q.emplace(i, j);
          grid[i][j] = -1;
          while (!q.empty()) {
            auto [cx, cy] = q.front();
            island.emplace_back(cx, cy);
            q.pop();
            for (int k = 0; k < 4; k++) {
              int tx = cx + vect[k][0];
              int ty = cy + vect[k][1];
              if (tx >= 0 && tx < n && ty >= 0 && ty < n && grid[tx][ty] == 1) {
                q.emplace(tx, ty);
                grid[tx][ty] = -1;
              }
            }
          }
          for (auto &&[x, y] : island) {
            q.emplace(x, y);
          }
          int steps = 0;
          while (!q.empty()) {
            int sz = q.size();
            for (int i = 0; i < sz; i++) {
              auto [x, y] = q.front();
              q.pop();
              for (int k = 0; k < 4; k++) {
                int tx = x + vect[k][0];
                int ty = y + vect[k][1];
                if (tx >= 0 && ty >= 0 && tx < n && ty < n) {
                  if (grid[tx][ty] == 0) {
                    q.emplace(tx, ty);
                    grid[tx][ty] = -1;
                  } else if (grid[tx][ty] == 1) {
                    return steps;
                  }
                }
              }
            }
            steps++;
          }
        }
      }
    }
    return -1;
  }
};
```



## 差分数组

> 前缀和的逆运算

### 拼车

([1094. 拼车 - 力扣（LeetCode）](https://leetcode.cn/problems/car-pooling/description/))

思路：记录每一个位置上下车的人数，然后遍历得到结果。

```c++
class Solution {
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        int cur = 0, to_max = 0;
        int get[1001],drop[1001];
        memset(get,0,sizeof(get));
        memset(drop,0,sizeof(drop));
        for (auto trip: trips){
            get[trip[1]] += trip[0];
            drop[trip[2]] += trip[0];
            to_max = max(to_max,trip[2]);
        }
        for (int i = 0; i <= to_max; i++){
            cur += get[i];
            cur -= drop[i];
            if (cur > capacity){
                return false;
            }
        }
        return true;
    }
};
```

# 链表专题

## 链表的反转

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *prev, *cur, *nxt;
        prev = NULL;
        cur = NULL;
        nxt = head;
        while (nxt != NULL){
            prev = cur;
            cur = nxt;
            nxt = cur->next;
            cur->next = prev;
        }
        return cur;
    }
};
```



# 二叉树专题

## 二叉搜索树

关键的性质是根节点的值大于左子树所有节点的值，小于右子树所有节点的值，且左子树和右子树也同样为二叉搜索树。

### 不同的二叉搜索树II

([95. 不同的二叉搜索树 II - 力扣（LeetCode）](https://leetcode.cn/problems/unique-binary-search-trees-ii/description/?envType=study-plan-v2&envId=dynamic-programming))

思路：回溯。递归得到所有可能的左子树和右子树，然后对于所有可能的根节点拼接左子树右子树，推入da'an

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    vector<TreeNode*> generateTrees(int start, int end){
        if (start > end){
            return {nullptr};
        }
        vector<TreeNode*> allTrees;
        //枚举可行根节点
        for (int i = start; i <= end; i++){
            //获得所有可行的左子树集合
            vector<TreeNode*> leftTrees = generateTrees(start,i - 1);
            //获得所有可行的右子树集合
            vector<TreeNode*> rightTrees = generateTrees(i + 1,end);

            //从左子树集合中选出一棵，从右子树集合中选出一棵，拼接到根节点上。
            for (auto &left: leftTrees){
                for (auto& right: rightTrees){
                    TreeNode * curTree = new TreeNode(i);
                    curTree->left = left;
                    curTree->right = right;
                    allTrees.emplace_back(curTree);
                }
            }
        }
        return allTrees;
    }
public:
    vector<TreeNode*> generateTrees(int n) {
        if (!n){
            return {};
        }

        return generateTrees(1, n);
    }
};
```

## 二叉树的中序遍历

按照左子树——根节点——右子树的顺序遍历二叉树

递归：

```c++
class Solution {
    void inorder(TreeNode* root, vector<int>& ans){
        if (!root){
            return;
        }
        inorder(root->left, ans);//左子树
        ans.push_back(root->val);//根节点
        inorder(root->right, ans);//右子树
    }
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        inorder(root, ans);
        return ans;
    }
};
```

迭代：

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        stack<TreeNode *>stk;
        while (root != nullptr || !stk.empty()){
            //左子树+根节点
            while (root != nullptr){
                stk.push(root);
                root = root->left;
            }
            root = stk.top();
            stk.pop();
            //当前根节点
            ans.push_back(root->val);
            //当前右子树
            root = root->right;
        }
        return ans;
    }
};
```

## 二叉树的构造

简单题：

### 将有序数组转化为二叉树

([108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/))

思路：由于中序遍历产生递增的数列，故采用每次递归确定根节点（这题答案不唯一，可以采用`(left + right)>>1 + rand() % 2`取下标）

```c++
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return helper(nums,0,nums.size() - 1);
    }
    TreeNode *helper(vector<int>& nums, int left, int right){
        if (left > right){
            return nullptr;
        }
        int mid = (left + right) / 2;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = helper(nums, left, mid - 1);
        root->right = helper(nums, mid + 1, right);
        return root;
    }
};
```

中等题：

### 从前序与中序遍历序列构造二叉树

### 从中序与后序遍历序列构造二叉树



# C++特性

## 哈希表OR红黑树

`unordered_map<,>`

### 字母异位词分组

([49. 字母异位词分组 - 力扣（LeetCode）](https://leetcode.cn/problems/group-anagrams/description/))

思路：定义一个红黑树`unordered_map<string,vector<string>>`将每个单词排序后结果作为`first`，每个单词的字母异位词推入其`second`。最后对红黑树遍历得到答案。

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,vector<string>> mp;
        for (int i = 0; i < strs.size(); i++){
            string key = strs[i];
            sort(key.begin(),key.end());
            mp[key].emplace_back(strs[i]);
        }
        vector<vector<string>>ans;
        for (auto p = mp.begin(); p != mp.end(); p++){
            ans.emplace_back(p->second);
        }
        return ans;
    }
};
```

### 只出现一次的数字II

([137. 只出现一次的数字 II - 力扣（LeetCode）](https://leetcode.cn/problems/single-number-ii/description/))

思路一：采用哈希表。

```c++
class Solution {
    unordered_map<int,int> hash;
public:
    int singleNumber(vector<int>& nums) {
        for (int i = 0; i < nums.size(); i++){
            if (hash.find(nums[i]) != hash.end()){
                hash[nums[i]]++;
            } else {
                hash[nums[i]] = 1;
            }
        }
        for (auto p = hash.begin(); p != hash.end(); p++){
            if (p->second == 1){
                return p->first;
            }
        }
        return -1;
    }
};
```

思路二：采用位运算。出现3次的数每一位是3的倍数，对每一位求和模3可以得到答案。

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for (int i = 0; i < 32; i++){
            int total = 0;
            for (const int &num : nums){
                total += ((num >> i) & 1);
            }
            if (total % 3){
                ans |= (1<<i);
            }
        }
        return ans;
    }
};
```

### 罗马数字转整数

([13. 罗马数字转整数 - 力扣（LeetCode）](https://leetcode.cn/problems/roman-to-integer/description/))

思路：采用哈希表存储所有字符与数值的对应关系，然后对于每一个字符，判断其后字符是否大于当前字符，如果大于，减去当前字符的对应数值，否则加上当前字符的对应数值。

```c++
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char,int> hash = {{'I',1},{'V',5},{'X',10},{'L',50},{'C',100},{'D',500},{'M',1000}};
        int ans = 0;
        for (int i = 0; i < s.size(); i++){
            if (i != s.size() - 1 && hash[s[i]] < hash[s[i + 1]]){
                ans -= hash[s[i]];
            } else {
                ans += hash[s[i]];
            }
        }
        return ans;
    }
};
```



## 哈希表

`unordered_set<>`

### 最长连续序列

([128. 最长连续序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-consecutive-sequence/description/))

思路：题目要求O(n)的时间复杂度。故采用哈希表记录数字出现情况，两次遍历。`while`是O(1)的时间复杂度。

`set.count()`表示集合中某元素的个数（集合元素唯一，故为0或1）。采用`unordered_set<>`不排序降低时间复杂度。

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> hash;
        for (const int &num : nums){
            hash.insert(num);
        }
        int ans = 0;
        for (const int &num : hash){
            if (!hash.count(num - 1)){
                int cur = 1;
                int curnum = num;
                while (hash.count(curnum + 1)){
                    curnum++;
                    cur++;
                }
                ans = max(ans,cur);
            }
        }
        return ans;
    }
};
```

## 二分查找

`lower_bound(,,)`查找第一个不小于target的迭代器。

`upper_bound(,,)`查找第一个不大于target的迭代器。

### 二叉搜索树的最近节点查询

([2476. 二叉搜索树最近节点查询 - 力扣（LeetCode）](https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/description/?envType=daily-question&envId=2024-02-24))

思路：先采用广度优先搜索/深度优先搜索遍历二叉树，将所有的值存入数组，然后对数组排序。对于每个目标值采用二分查找，得到结果。

==注意==：如果顺序查找会超时，必须采用二分查找。

```c++
class Solution {
    int vect[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};
public:
    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {
        vector<int> nums;
        queue<TreeNode *>nodes;
        nodes.emplace(root);
        while (!nodes.empty()){
            TreeNode *cur = nodes.front();
            nodes.pop();
            nums.emplace_back(cur->val);
            if (cur->left){
                nodes.emplace(cur->left);
            }
            if (cur->right){
                nodes.emplace(cur->right);
            }
        }
        sort(nums.begin(),nums.end());
        vector<vector<int>>ans;
        for (int i = 0; i < queries.size(); i++){
            int minval = -1,maxval = - 1;
            auto p = lower_bound(nums.begin(),nums.end(),queries[i]);
            if (p != nums.end()){
                maxval = *p;
                if (*p == queries[i]){
                    ans.push_back({maxval,maxval});
                    continue;
                }
            }
            if (p != nums.begin()){
                minval = *(p - 1);
            }
            ans.push_back({minval,maxval});
        }
        return ans;
    }
};
```

## 基于lambda表达式形式的函数说明

[lambda 表达式 (C++11 起) - cppreference.com](https://zh.cppreference.com/w/cpp/language/lambda)

### 寻找峰值

([162. 寻找峰值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-peak-element/description/))

思路：找到峰则返回，否则判断是否左移或右移。

==注意==：要对下标-1和n特殊处理，否则会发生数组越界。

```c++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int low = 0, high = nums.size(), n = nums.size();
        auto get = [&](int i) -> pair<int,int>{
            if (i == -1 || i == n){
                return {0,0};
            }
            return {1, nums[i]};
        };
        while (low <= high){
            int mid = (low + high) / 2;
            if (get(mid - 1) < get(mid) && get(mid) > get(mid + 1)){
                return mid;
            } else if (get(mid) < get(mid + 1)){
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return 0;
    }
};
```

### 受限条件下可到达节点的数目

([2368. 受限条件下可到达节点的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/reachable-nodes-with-restrictions/description/))

思路：深度优先搜索，注意不能回头，为了简化遍历，采用一个辅助数列存储各个点的子节点，递归时传入当前节点和上一个节点，防止重复遍历。

==注意==：学习本题函数的写法

```c++
class Solution {
public:
    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {
        vector<int> isrestricted(n);
        for (auto r : restricted){
            isrestricted[r] = 1;
        }

        vector<vector<int>> g(n);
        for (auto v : edges){
            g[v[0]].push_back(v[1]);
            g[v[1]].push_back(v[0]);
        }

        int cut = 0;
        function<void(int, int)> dfs = [&](int x, int f){
            cut++;
            for (auto &y : g[x]){
                if (y != f && !isrestricted[y]){
                    dfs(y,x);
                }
            }
        };
        dfs(0,-1);
        return cut;
    }
};
```



## 字符串类String

采用`substr(beginIndes,length)`获取子串

### 重复的DNA序列

([187. 重复的DNA序列 - 力扣（LeetCode）](https://leetcode.cn/problems/repeated-dna-sequences/description/))

思路：哈希表，一重循环

```c++
class Solution {
    vector<string> ans;
    unordered_map<string,int> hash;
public:
    vector<string> findRepeatedDnaSequences(string s) {
        int n = s.size();
        for (int i = 0; i < n - 9; i++){
            string ss = s.substr(i,10);
            if (hash.find(ss) != hash.end() && hash[ss] == 1){
                ans.push_back(ss);
            }
            hash[ss]++;
        }
        return ans;
    }
};
```

# 脑筋急转弯

### 删除链表中的节点

([237. 删除链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-node-in-a-linked-list/description/))

思路：不删除当前节点，而是将当前节点的值复制给下一个节点，不断遍历。

```c++
class Solution {
public:
    void deleteNode(ListNode* node) {
         while (node->next->next != NULL){
             node->val = node->next->val;
             node = node->next;
         }
         node->val = node->next->val;
         node->next = NULL;
    }
};
```

